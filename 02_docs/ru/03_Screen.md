# Класс Screen

## Общая информация

Объекты класса Screen являются главными контейнерами для объектов [Entity](04_Entity.md), отрисовываемых на экране.

Чтобы различать разные Screen друг от друга, всем им соответствуют разные ScreenID в файле ScreenID.h. Чтобы запустить Screen, можно передать указатель на него в функцию **[open_screen()](05_Controller.md#void-open_screenscreen-screen)** класса Controller или передать ScreenID в перегруженную версию этой функции, **[open_screen()](05_Controller.md#void-open_screenscreenid-sid-bool-recreate--false)**, и она создаст соответствующий Screen автоматически.

Классы Screen могут быть «статичными». Это значит, что объекты таких классов будут автоматически сохраняться в памяти и не будут пересоздаваться. Такие объекты сохранят своё состояние даже если открыть другой экран. Вы также можете пересоздать такой Screen (например, если хотите начать новую игру), вызывав функцию **[Controller::open_screen()](05_Controller.md#void-open_screenscreenid-sid-bool-recreate--false)** с необходимым ScreenID и значением **true**.

Вообще, Screen наследует класс Entity, так что можно перегрузить некоторые функции Entity. Это также означает, что вы можете поместить Screen внутрь Screen, если хотите.


## Наследование класса Screen

Объект самого класса Screen может быть открыт, хотя он ничего не делает и не содержит. Так что вы получите работающий класс, даже если просто наследуете класс Screen и не перегружаете ни одной из его виртуальных функций.

Следующие функции класса Screen могут быть перегружены:

##### `void start()`
Функция, которая вызывается при открытии объекта класса Screen.  
(Например, можно проверить, открывается ли Screen впервые и сделать в этом случае что-то особенное.)  
**start()** класса Screen ничего не делает.  

----
##### `void save_state(ofstream& fout)`
Функция, которая вызывается, когда приложение сохраняет своё состояние в переданный поток вывода. Она может использоваться для сохранения информации, которая будет недоступна во время следующей сессии, чтобы её можно было восстановить.  
(Например, незачем сохранять состояние меню, так как оно не меняется. А вот уровень, где игрок мог что-то переместить, стоит сохранить.)  
**save_state()** класса Screen ничего не делает.  

----
##### `void load_state(ifstream& fin)`
Функция, которая вызывается, когда приложение загружает состояние из переданного потока ввода. Она используется, чтобы загружать состояние, сохранённое предыдущей функцией.  
(Например, можно загрузить сохранённый уровень.)  
**load_state()** класса Screen ничего не делает.  

----
##### `ScreenID id()`
Функция, возвращающая соответствующий ScreenID, чтобы можно было отличать разные классы друг от друга. Вы *должны* перегрузить эту функцию. 
**id()** класса Screen возвращает **s_UNKNOWN_ID** из файла ScreenID.h.

----
##### `bool is_static()`
Функция, которая возвращает **true**, если этот класс статичен. В Screen есть переменная-член bool **_static**, устанавливаемая на **true** или **false** в конструкторе. Её значение и возвращается этой функцией.
Класс Screen возвращает **false**.


## ScreenID

Всем классам Screen нужен индекс. Они содержатся в файле ScreenID.h. При наследовании класса Screen вы должны добавить новый индекс в перечисление ScreenID и отредактировать функцию **create_screen()** в файле ScreenID.cpp, чтобы она создавала ваш класс по переданному ID. Тогда приложение сможет отличить ваш класс от других. 
   
   
**Предыдущий файл:** [Поток программы](02_Workflow.md)  
**[Содержание](00_Contents.md)**  
**Следующий файл:** [Класс Entity](04_Entity.md)