# Класс State

## Общая информация

Класс State предназначен для хранения глобальных («постоянных») переменных. Объект State можно сохранить в файл или загрузить из файла. Чтобы различать типы сохраняемых объектов, класс использует значения типа **char**, соответствующие некоторым типам или классам. Например, **'i'** соответствует типу int, а **'s'** — классу string. Чтобы хранить другие классы в State, вам нужно добавить функции в State.h — в противном случае объекты этих классов не будут сохранены в файл. 

Каждой переменной соответствует два ключа. Например, пара ключей **{"a","key"}** не равна паре **{"b","key"}**. Значением любой переменной может быть объект любого типа. Если хотите, вы можете изменить тип значения (например, заменить числовое значение переменной, которой соответствует пара ключей **{"a","key"}**, строковым значением).

Хранятся не сами значения, а указатели на них. Это значит, что если вы вручную очистите память, то значения будут потеряны. Если вы обновляете или заменяете значения через функции класса State, память будет очищаться только при необходимости.

Функции State статичны, то есть вы можете использовать их из любого места программы.

## Functions  

##### `static void* persistent(string first_key, string second_key)`
Возвращает указатель на значение переменной, которой соответствует пара **first_key**, **second_key**. Если такой паре не соответствует переменная, возвращается 0 (или, если **[DEBUG_EXCEPTION_ON_UNALLOCATED_VARIABLE](22_settings_h.md#debug_exception_on_unallocated_variable)** равняется 1, бросается строка как исключение).  
(Вам нужно будет привести указатель типа **void*** к типу, который вам нужен. Предполагается, что вы знаете тип запрашиваемой переменной.)  

----
##### `template<typename T> static void set_persistent(string first_key, string second_key, T* p)`
Добавляет переменную, которой соответствует пара **first_key**, **second_key**, и сохраняет указатель на её значение. Если указанной паре уже соответствует переменная, она будет заменена данным значением. Если же адрес соответствующей переменной равен переданному адресу, переменная не удаляется.  

----
##### `template<typename T> static void update_persistent(string first_key, string second_key, T& value)`
Ищет указатель на переменную, которой соответствует пара **first_key**, **second_key**. Если такой не найдено, ничего не делается. В противном случае её значение заменяется переданным значением **value**. Если найденный указатель равен 0, выделяет новую память и обновляет её значением **value**.  

## Устройство класса State

##### `void save(ofstream&)`
Записывает все переменные в переданный поток вывода.  
(Содержит **switch** значений **char**, соответствующих разным типам. Если вам нужны дополнительные типы, вам нужно будет изменить эту функцию.)  

----
##### `void load(ifstream&)`
Считывает переменные из переданного потока ввода.  
(Содержит **switch** значений **char**, соответствующих разным типам. Если вам нужны дополнительные типы, вам нужно будет изменить эту функцию.)  

----
##### `template<typename T> static char get_type(T*) { return 'U'; }`
##### `static char get_type(int*) { return 'i'; }`
##### `static char get_type(string*) { return 's'; }`
Возвращает **char**, соответствующий переданном типу.  
(Значение **'U'** означает «неизвестный тип», **'i'** — int, **'s'** — string. Если вам нужны дополнительные типы, вам нужно будет перегрузить эту функцию.)  

----
##### `void save_value(int*, ofstream&)`
##### `void save_value(string*, ofstream&)`
Записывает значение переданной переменной в переданный поток вывода.  
(Если вам нужны дополнительные типы, вам нужно будет перегрузить эту функцию.)  

----
##### `int* load_value(ifstream&, identity<int>)`
##### `string* load_value(ifstream&, identity<string>)`
Считывает значение переменной указанного типа из переданного потока ввода.  
(Если вам нужны дополнительные типы, вам нужно будет перегрузить эту функцию.)  
   
   
**Предыдущий файл:** [Класс Input](08_Input.md)  
**[Содержание](00_Contents.md)**  
**Следующий файл:** [Класс Logger](10_Logger.md)