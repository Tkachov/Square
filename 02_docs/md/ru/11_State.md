# класс State

## Общая информация

Класс State используется, чтобы хранить глобальные («постоянные») переменные и их значения. Объекты State могут быть сохранены в файл и загружены из него. Чтобы определить тип сохраняемого объекта, этот класс использует **char**-значения, соответствующие определённым типам или классам. Например, **'i'** соответствует типу int, а **'s'** — классу std::string. Если вы храните другие классы в объекте State, вам нужно добавить функции в файл state.h или переменные данных типов не будут сохраняться в файл. 

Чтобы получить переменную, нужно использовать два ключа. Это значит что значение для пары **{"a","key"}** не равно значению для пары **{"b","key"}**. Любой тип может храниться как значение переменной и вы можете изменить тип значения, если вы захотите (т.е. вы можете заменить значение пары **{"a","key"}** с типом int на значение с типом string).

Хранятся не сами значения, а указатели на них. Это значит, что если вы освободите память под значение вручную, оно будет потеряно. При обновлении или замене значения с помощью функций класса State память будет освобождаться, если это необходимо.

Объект State хранится в объекте [Game](05_Game.md), но указатель на него передаётся объектам [Screen](03_Screen.md). Там функции класса State и используются.

## Функции  

##### `void save(ofstream&)`
Записывает все переменные в переданный поток.  
(Содержит **switch** **char**-значений, соответствующих разным типам. Если добавите новый тип, нужно будет изменить функцию.)  

----
##### `void load(ifstream&)`
Считывает все переменные из переданного потока.  
(Содержит **switch** **char**-значений, соответствующих разным типам. Если добавите новый тип, нужно будет изменить функцию.)  

----
##### `template<typename T> static char get_type(T*) { return 'U'; }`
##### `static char get_type(int*) { return 'i'; }`
##### `static char get_type(string*) { return 's'; }`
Возвращает **char**-значение, соответствующее переданному типу.  
(Значение **'U'** означает «Unknown type» («Неизвестный тип»), **'i'** — int, **'s'** — string. Если добавите новый тип, нужно будет перегрузить функцию.)  

----
##### `void save_value(int*, ofstream&)`
##### `void save_value(string*, ofstream&)`
Записывает значение переменной в переданный поток.  
(Если добавите новый тип, нужно будет перегрузить функцию.)  

----
##### `int* load_value(ifstream&, identity<int>)`
##### `string* load_value(ifstream&, identity<string>)`
Считывает значение переменной из переданного потока.  
(Если добавите новый тип, нужно будет перегрузить функцию.)  

----
##### `void* persistent(string first_key, string second_key)`
Возвращает указатель на переменную для пары переданных ключей **first_key**, **second_key**. Если переданной паре не соответствует переменная, возвращает 0 (или бросает исключение в виде **std::string**, если определена константа **[DBG_STOP_ON_UNALLOCATED_VARIABLE](19_debug_h.md#dbg_stop_on_unallocated_variable)**).  
(Вам нужно будет преобразовать возвращённый указатель типа **void*** к нужному вам типу. Предполагается, что вы знаете тип запрашиваемой переменной.)  

----
##### `template<typename T> void set_persistent(string first_key, string second_key, T* p)`
Добавляет переменную, соответствующую паре переданных ключей **first_key**, **second_key** и сохраняющей указатель на значение. Если данной паре ключей уже соответствует значение, оно будет освобождено и заменено переданным значением. Если указатель на значение и переданный указатель совпадают, он не будет освобождён.  

----
##### `template<typename T> void update_persistent(string first_key, string second_key, T& value)`
Ищет значение, соответствующее паре переданных ключей **first_key**, **second_key**. Если данной паре не соответствуют значения, ничего не происходит. В противном случае значение указателя обновляется переданным по ссылке значением **value**. Если указатель переменной равен 0, выделяет память под объект и обновляет его значение переданным по ссылке значением **value**.  
   
   
**Предыдущий файл:** [класс Logger](10_Logger.md)  
**[Содержание](00_Contents.md)**  
**Следующий файл:** [класс Image](12_Image.md)

