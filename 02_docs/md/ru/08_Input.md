# класс Input

## Общая информация

Класс Input обрабатывает ввод от пользователя каждый раз, когда объект [Game](05_Game.md) просит его. Объекты класса [Screen](03_Screen.md) получают указатель на объект Input и могут использовать его, чтобы реагировать на действия игрока. Объекты Screen должны оповещать объекты [Object](04_Object.md) и передавать им этот указатель, чтобы реагировать могли и они.

Вы можете узнать, нажаты, зажаты или отпущены клавиши клавиатуры или кнопки мыши в данный момент. Кроме того, вы можете узнать координаты курсора мыши, а также узнать, не пытается ли пользователь закрыть приложение.

К тому же, вы можете «съесть» состояние клавиш и мыши. Например, была нажата левая кнопка мыши. Если вы проверите, была ли она нажата, то вам будет возвращён результат **true**. После того, как вы «съедите» это состояние и снова проверите, была ли нажата кнопка мыши, вам будет возвращён результат **false**. Это может быть использовано, чтобы предотвратить обработку одного нажатия как нескольких (например, если клавиша Escape закрывает окна по одному, она закроет их все разом, если вы не не «съедите» это событие).

Вы также можете узнать, было ли состояние «съедено».

Кроме того, вы можете «поставить объект на паузу» и «отключить паузу». Это не меняет его поведение, но с помощью этого можно создать систему, в которой некоторые объекты не реагируют на действия пользователя, потому что вы так хотите (например, герой не должен перемещаться, пока игра стоит на паузе, но само меню паузы должно реагировать на действия пользователя).

Пауза сохраняется между вызовами функции **update()**, а другие состояния — нет. Это значит, что если вы съели событие нажатия клавиши во время одного вызова **update()**, оно не будет съеденым во время следующего вызова (если вы не съедите его снова).

Клавиши и кнопки мыши могут иметь одно из следующих состояний:
* 0 — не нажата;
* 1 — только что нажата;
* 2 — зажата (уже была нажата, но ещё не была отпущена);
* 3 — только что отпущена.

Состояние 1 становится состоянием 2 и состояние 3 становится состоянием 0 на следующий вызов **update()** если общее (нажата/не нажата) состояние останется прежним.

## Функции

##### `short int key(int k)`
Возвращает текущее состояние клавиши **k**.  

----
##### `short int mouse(int m)`
Возвращает текущее состояние кнопки мыши **m**.  

----
##### `int mouse_x()`
Возвращает x-координату курсора.  

----
##### `int mouse_y()`
Возвращает y-координату курсора.  

----
##### `bool key_eaten(int k)`
Возвращает **true**, если состояние клавиши **k** было съедено во время текущего вызова **update()**.  

----
##### `void key_eat(int k)`
Съедает состояние клавиши **k**.  

----
##### `bool mouse_eaten(int m)`
Возвращает **true**, если состояние кнопки мыши **m** было съедено во время текущего вызова **update()**.  

----
##### `void mouse_eat(int m)`
Съедает состояние кнопки мыши **m**.  

----
##### `bool key_press(int k, bool eat = false)`
Возвращает **true**, если клавиша **k** только что была нажата (состояние 1). Если параметр **eat** равен **true**, съедает состояние.  

----
##### `bool key_hold(int k, bool eat = false)`
Возвращает **true**, если клавиша **k** зажата (состояние 2). Если параметр **eat** равен **true**, съедает состояние.  

----
##### `bool key_release(int k, bool eat = false)`
Возвращает **true**, если клавиша **k** только что была отпущена (состояние 3). Если параметр **eat** равен **true**, съедает состояние.  

----
##### `bool mouse_press(int m, bool eat = false)`
Возвращает **true**, если кнопка мыши **m** только что была нажата (состояние 1). Если параметр **eat** равен **true**, съедает состояние.  

----
##### `bool mouse_hold(int m, bool eat = false)`
Возвращает **true**, если кнопка мыши **m** зажата (состояние 2). Если параметр **eat** равен **true**, съедает состояние.  

----
##### `bool mouse_release(int m, bool eat = false)`
Возвращает **true**, если кнопка мыши **m** только что была отпущена (состояние 3). Если параметр **eat** равен **true**, съедает состояние.  

----
##### `bool terminate()`
Возвращает **true**, если пользователь нажал кнопку «Закрыть», нажал Alt+F4 или убивает процесс через Диспетчер задач.  

----
##### `bool paused()`
Возвращает **true**, если объект поставлен на паузу.  

----
##### `void pause()`
Ставит объект на паузу.  

----
##### `void unpause()`
Отключает паузу.  

----
##### `void repeating(bool)`
Устанавливает, повторять события клавиш и кнопок мыши (т.е. состояние 1 сможет длиться больше, чем один вызов **update()**) или не повторять их.  
Может быть полезным для полей ввода текста, в которых удерживание клавиши зажатой печатает символ снова и снова.  
(Вы можете установить задержку и интервал для этих событий, отредактировав данную функцию.)

## Переменные

##### `vector<keychar> keyboard_string`
Содержит все нажатые в данный момент клавиши в порядке, в котором они были нажаты.  
Хранятся только клавиши, у которых есть соответствующее значение в кодировке Unicode.  
Определение структуры **keychar**:

     struct keychar {
      string unicode;
      int keycode;
     };

Заметьте, что в данной переменной хранятся только те клавиши, которые были только что нажаты (т.е. имеют в данный момент состояние 1).  
(Например, если пользователь одновременно нажмёт клавиши A, B и C, соответствующие структуры keychar попадут в контейнер vector. Если после этого пользователь нажмёт D, в контейнере будет содержаться лишь keychar для D. Если пользователь ничего не нажимал, контейнер будет пуст.)  
   
   
**Предыдущий файл:** [класс String_Table](07_String_Table.md)  
**[Содержание](00_Contents.md)**  
**Следующий файл:** [класс Loader](09_Loader.md)

